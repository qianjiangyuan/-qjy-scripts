package image

import (
	"bytes"
	"crypto/tls"
	"encoding/json"
	"fmt"
	"github.com/gin-gonic/gin"
	"github.com/xxmyjk/xintong/backend/pkg/app/connect"
	"github.com/xxmyjk/xintong/backend/pkg/app/controller"
	"github.com/xxmyjk/xintong/backend/pkg/app/controller/upload"
	imageDao "github.com/xxmyjk/xintong/backend/pkg/app/dao/image"
	"github.com/xxmyjk/xintong/backend/pkg/app/model/image"
	"github.com/xxmyjk/xintong/backend/pkg/app/util"
	"go.mongodb.org/mongo-driver/bson/primitive"
	"io/ioutil"
	"net/http"
	"net/url"
	"os/exec"
)

type Params struct {
	Name string `json:"name" `
}
type QueryParams struct {
	mParams  Params
	PageNum  int64 `json:"pagenum" `
	PageSize int64 `json:"pagesize" `
}

func detailHarborImage(m image.HanborImage,ch chan []image.HanborImage) {


	// Generated by curl-to-Go: https://mholt.github.io/curl-to-go
	imageName :=url.QueryEscape(m.Name)
	// TODO: This is insecure; use only in dev environments.
	tr := &http.Transport{
		TLSClientConfig: &tls.Config{InsecureSkipVerify: true},
	}
	client := &http.Client{Transport: tr}

	req, err := http.NewRequest("GET", "https://core.harbor.domain/api/repositories/"+imageName+"/tags?detail=1", nil)
	if err != nil {
		// handle err
	}
	req.SetBasicAuth("admin", "Harbor12345")
	req.Header.Set("Content-Type", "application/json")

	resp, err := client.Do(req)
	if err != nil {
		// handle err
	}
	defer resp.Body.Close()
	body, _ := ioutil.ReadAll(resp.Body)
	var haborImageVersions []image.HarborImageVersion
	err = json.Unmarshal(body, &haborImageVersions)
	images := make([]image.HanborImage,0)
	for _,harborImageVersion := range haborImageVersions {
		hImage :=image.HanborImage{}
		util.CopyStruct(&m,&hImage)
		hImage.Version=harborImageVersion.Name
		hImage.ImageUrl="core.harbor.domain/"+m.Name+":"+hImage.Version
		fmt.Println("name="+hImage.Name)
		fmt.Println("version"+hImage.Version)
		images=append(images,hImage )
	}
	ch <- images


}
func searchImages()[]image.HanborImage{

	// Generated by curl-to-Go: https://mholt.github.io/curl-to-go

	// TODO: This is insecure; use only in dev environments.
	 /*
	tr := &http.Transport{
		TLSClientConfig: &tls.Config{InsecureSkipVerify: true},
	}
	client := &http.Client{Transport: tr}

	req, err := http.NewRequest("GET", "https://core.harbor.domain/api/repositories?page=1&page_size=100&project_id=2", nil)
	if err != nil {
		// handle err
	}
	req.SetBasicAuth("admin", "Harbor12345")
	req.Header.Set("Content-Type", "application/json")

	resp, err := client.Do(req)
	if err != nil {
		// handle err
	}
	defer resp.Body.Close()
	body, _ := ioutil.ReadAll(resp.Body)
	var haborImages []image.HanborImage
	err = json.Unmarshal(body, &haborImages)
	ch := make(chan []image.HanborImage,len(haborImages))
	for _,harborImage := range haborImages {
		fmt.Println(harborImage)
		fmt.Println(harborImage.Name)
		go detailHarborImage(harborImage,ch)
	}
	images := make([]image.HanborImage,0)
	for i := 0; i < cap(ch); i++ {
		images=append(images,<-ch...)
	}
	*/
	images := make([]image.HanborImage,0)
	return images

}
func Save(ctx *gin.Context) {
	m := image.NewImage()
	err := ctx.Bind(&m)
	if controller.ErrCatch(err, ctx) {
		return
	}
	igDao := imageDao.NewImageDao()
	rs, err := igDao.Insert(m, igDao)
	if controller.ErrCatch(err, ctx) {
		return
	}
	go loadImage(m)

	ctx.JSON(200, &gin.H{
		"code": 0,
		"msg":  "OK",
		"data": rs,
	})

	return
}

func Update(ctx *gin.Context) {
	m := image.Image{}
	err := ctx.Bind(&m)
	if controller.ErrCatch(err, ctx) {
		return
	}
	igDao := imageDao.NewImageDao()
	rs, err := igDao.Update(m, m.ID, igDao)
	if controller.ErrCatch(err, ctx) {
		return
	}
	loadImage(m)
	ctx.JSON(200, &gin.H{
		"code": 0,
		"msg":  "OK",
		"data": rs,
	})
	return
}

func Detail(ctx *gin.Context) {
	id := ctx.Query("id")
	igDao := imageDao.NewImageDao()
	err := igDao.SelectById(id, igDao)
	if controller.ErrCatch(err, ctx) {
		return
	}
	files, err := upload.GetAllFile(igDao.Model.Url, 1, 100)
	if err != nil {
		ctx.JSON(200, &gin.H{
			"code": -1,
			"msg":  err.Error(),
			"data": err,
		})
		return
	}
	imageVo := image.ImageVo{}
	imageVo.Image = igDao.Model
	imageVo.Files = files.Files
	imageVo.FileTotal = files.Total
	ctx.JSON(200, &gin.H{
		"code": 0,
		"msg":  "OK",
		"data": imageVo,
	})
	return
}

func QueryPageList(ctx *gin.Context) {
	/*
	query := QueryParams{}
	err := ctx.Bind(&query)
	if controller.ErrCatch(err, ctx) {
		return
	}
	queryMap := make(map[string]string)
	queryMap["name"] = query.mParams.Name
	igDao := imageDao.NewImageDao()
	_,err = igDao.GetSelectPageList(queryMap, query.PageNum, query.PageSize, igDao)
	if controller.ErrCatch(err, ctx) {
		return
	}*/
	images :=searchImages()
	ctx.JSON(200, &gin.H{
		"code": 0,
		"msg":  "OK",
		"data": images,
	})

	return
}

func Deletes(ctx *gin.Context) {
	ids := []primitive.ObjectID{}
	err := ctx.Bind(&ids)
	if controller.ErrCatch(err, ctx) {
		return
	}
	igDao := imageDao.NewImageDao()
	err = igDao.Deletes(ids, igDao)
	if controller.ErrCatch(err, ctx) {
		return
	}
	ctx.JSON(200, &gin.H{
		"code": 0,
		"msg":  "OK",
		"data": "",
	})
}

func loadImage(image image.Image) error {
	//cmdStr := "/Users/like/WorkSpace/xintong/backend/deploy/sh/load.sh " + upload.GetPath(image.Url) + "/" + image.FileName + " " + "core.harbor.domain/modelzoo" + " " + image.Name + " " + image.Version
	conf := connect.Conf
	script := conf.GetString("registry.script")
	storePath := upload.GetPath(image.Url) + "/" + image.FileName
	repoUrl := conf.GetString("registry.url") + "/" + conf.GetString("registry.repo")
	imageName := image.Name
	imageVersion := image.Version

	cmdStr := fmt.Sprintf(
		"%s %s %s %s %s",
		script,
		storePath,
		repoUrl,
		imageName, imageVersion,
	)
	fmt.Println(cmdStr)

	cmd := exec.Command("sh", "-c", cmdStr)
	var out bytes.Buffer
	var stderr bytes.Buffer
	cmd.Stdout = &out
	cmd.Stderr = &stderr
	err := cmd.Run()
	if err != nil {
		fmt.Printf("error %s %s ", err.Error(), stderr.String())
	}
	fmt.Printf("out= %s", out.String())
	return err

}
